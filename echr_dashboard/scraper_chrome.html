<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ECHR HUDOC Scraper</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; padding: 24px; }
h1 { font-size: 1.5rem; margin-bottom: 8px; color: #38bdf8; }
.subtitle { color: #94a3b8; margin-bottom: 24px; font-size: 0.9rem; }
.controls { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: center; }
button { padding: 10px 20px; border: none; border-radius: 8px; font-size: 0.9rem; cursor: pointer; font-weight: 600; }
button.primary { background: #2563eb; color: white; }
button.primary:hover { background: #1d4ed8; }
button.primary:disabled { background: #334155; color: #64748b; cursor: not-allowed; }
button.danger { background: #dc2626; color: white; }
button.secondary { background: #334155; color: #e2e8f0; }
.progress-container { background: #1e293b; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
.progress-bar-outer { background: #334155; border-radius: 8px; height: 24px; overflow: hidden; margin: 12px 0; }
.progress-bar-inner { background: linear-gradient(90deg, #2563eb, #38bdf8); height: 100%; border-radius: 8px; transition: width 0.3s; }
.stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-top: 12px; }
.stat { background: #1e293b; padding: 12px; border-radius: 8px; text-align: center; }
.stat .value { font-size: 1.5rem; font-weight: 700; color: #38bdf8; }
.stat .label { font-size: 0.75rem; color: #94a3b8; margin-top: 4px; }
#log { background: #0c0c1d; border: 1px solid #1e293b; border-radius: 8px; padding: 16px; height: 400px; overflow-y: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; line-height: 1.6; }
.log-info { color: #38bdf8; }
.log-ok { color: #4ade80; }
.log-warn { color: #fbbf24; }
.log-err { color: #f87171; }
.log-dim { color: #64748b; }
textarea { width: 100%; height: 80px; background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 8px; padding: 12px; font-family: monospace; font-size: 0.85rem; margin-bottom: 12px; }
label { font-size: 0.85rem; color: #94a3b8; display: block; margin-bottom: 4px; }
</style>
</head>
<body>
<h1>ECHR HUDOC Scraper</h1>
<p class="subtitle">Fetches judgments from HUDOC with proper paragraph handling. Runs in-browser via HUDOC API.</p>

<label for="caseIds">Case IDs (comma-separated, or leave empty to search recent judgments):</label>
<textarea id="caseIds" placeholder="001-246126,001-248200,001-248208,..."></textarea>

<div class="controls">
    <button class="primary" id="btnStart" onclick="startScraping()">Start Scraping</button>
    <button class="danger" id="btnStop" onclick="stopScraping()" style="display:none">Stop</button>
    <button class="secondary" id="btnDownload" onclick="downloadResults()" style="display:none">Download JSONL</button>
    <span id="statusText" style="color:#94a3b8; font-size:0.85rem;"></span>
</div>

<div class="progress-container">
    <div style="display:flex; justify-content:space-between;">
        <span id="progressLabel">Ready</span>
        <span id="progressPct">0%</span>
    </div>
    <div class="progress-bar-outer">
        <div class="progress-bar-inner" id="progressBar" style="width:0%"></div>
    </div>
    <div class="stats">
        <div class="stat"><div class="value" id="statTotal">0</div><div class="label">Total</div></div>
        <div class="stat"><div class="value" id="statDone">0</div><div class="label">Fetched</div></div>
        <div class="stat"><div class="value" id="statParas">0</div><div class="label">Paragraphs</div></div>
        <div class="stat"><div class="value" id="statErrors">0</div><div class="label">Errors</div></div>
    </div>
</div>

<div id="log"></div>

<script>
// ============================================================
// Configuration
// ============================================================
const HUDOC_SEARCH = 'https://hudoc.echr.coe.int/app/query/results';
const HUDOC_DOC = 'https://hudoc.echr.coe.int/app/conversion/docx/html/body';
const SEARCH_FIELDS = 'itemid,docname,appno,conclusion,importance,originatingbody,doctypebranch,respondent,respondentOrderEng,article,violation,nonviolation,judgementdate,languageisocode,ecli,separateopinion,kpthesaurus,scl';
const DELAY_MS = 1500;  // delay between requests to be polite

let running = false;
let results = [];
let errors = 0;

// ============================================================
// Logging
// ============================================================
function log(msg, cls = 'log-info') {
    const el = document.getElementById('log');
    const time = new Date().toLocaleTimeString();
    el.innerHTML += `<div class="${cls}"><span class="log-dim">[${time}]</span> ${msg}</div>`;
    el.scrollTop = el.scrollHeight;
}

function updateProgress(done, total) {
    const pct = total > 0 ? Math.round(done / total * 100) : 0;
    document.getElementById('progressBar').style.width = pct + '%';
    document.getElementById('progressPct').textContent = pct + '%';
    document.getElementById('progressLabel').textContent = `${done} / ${total} cases`;
    document.getElementById('statDone').textContent = done;
    document.getElementById('statTotal').textContent = total;
    document.getElementById('statErrors').textContent = errors;
}

// ============================================================
// HUDOC Search API
// ============================================================
async function searchHudoc(count = 100) {
    const query = [
        'contentsitename:ECHR',
        '(NOT (doctype:PR OR doctype:HFCOMOLD OR doctype:HECOMOLD))',
        '(doctypebranch:JUDGMENTS OR doctypebranch:CHAMBER OR doctypebranch:GRANDCHAMBER)',
        'languageisocode:"ENG"'
    ].join(' AND ');

    const params = new URLSearchParams({
        query, select: SEARCH_FIELDS,
        sort: 'kpdate Descending',
        start: 0, length: Math.min(count, 500)
    });

    log('Searching HUDOC for recent judgments...');
    const resp = await fetch(HUDOC_SEARCH + '?' + params);
    const data = await resp.json();
    log(`Found ${data.resultcount} total judgments, fetching ${Math.min(count, data.results?.length || 0)}`, 'log-ok');
    return data.results?.map(r => r.columns) || [];
}

async function fetchMetadataByIds(ids) {
    // Fetch metadata for specific case IDs in batches
    const batchSize = 20;
    let allResults = [];

    for (let i = 0; i < ids.length; i += batchSize) {
        if (!running) break;
        const batch = ids.slice(i, i + batchSize);
        const idClauses = batch.map(id => `itemid:"${id}"`).join(' OR ');
        const query = `contentsitename:ECHR AND (${idClauses})`;

        const params = new URLSearchParams({
            query, select: SEARCH_FIELDS,
            sort: 'kpdate Descending',
            start: 0, length: batch.length
        });

        try {
            const resp = await fetch(HUDOC_SEARCH + '?' + params);
            const data = await resp.json();
            const found = data.results?.map(r => r.columns) || [];
            allResults = allResults.concat(found);
            log(`Metadata batch ${Math.floor(i/batchSize)+1}: found ${found.length}/${batch.length}`, 'log-info');
        } catch (e) {
            log(`Metadata batch error: ${e.message}`, 'log-err');
        }

        if (i + batchSize < ids.length) await sleep(500);
    }

    return allResults;
}

// ============================================================
// Document Fetching & Parsing
// ============================================================
async function fetchDocumentHtml(itemId) {
    const params = new URLSearchParams({ library: 'ECHR', id: itemId });
    const resp = await fetch(HUDOC_DOC + '?' + params);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.text();
}

function parseEchrHtml(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const allParas = doc.querySelectorAll('p');

    // Extract all non-empty paragraphs
    const paragraphs = [];
    for (const p of allParas) {
        const text = p.textContent.trim();
        if (text.length > 0) {
            paragraphs.push(text);
        }
    }

    // Now segment into ECHR sections
    return segmentParagraphs(paragraphs);
}

// ============================================================
// Section Detection — maps ECHR headings to our schema
// ============================================================
const SECTION_PATTERNS = [
    { name: 'introduction', re: /^INTRODUCTION$/i },
    { name: 'facts', re: /^THE\s+FACTS$/i },
    { name: 'relevant_legal_framework_practice', re: /^RELEVANT\s+(DOMESTIC\s+)?(LEGAL\s+FRAMEWORK|LAW)((\s+AND\s+PRACTICE)?|(\s+AND\/OR\s+PRACTICE)?)$/i },
    { name: 'relevant_legal_framework_practice', re: /^RELEVANT\s+FRAMEWORK$/i },
    { name: 'law', re: /^THE\s+LAW$/i },
    { name: 'reasons_the_court_unanimously', re: /^FOR\s+THESE\s+REASONS/i },
];

// Separate opinion indicators (after operative part)
const SEPARATE_OPINION_RE = /^(JOINT\s+)?(PARTLY\s+)?(CONCURRING|DISSENTING|SEPARATE)\s+OPINION/i;

function segmentParagraphs(paragraphs) {
    const sections = {
        header: [],
        introduction: [],
        facts: [],
        relevant_legal_framework_practice: [],
        legal_context: [],
        law: [],
        reasons_the_court_unanimously: [],
        separate_opinions: []
    };

    let currentSection = 'header';
    let inSeparateOpinion = false;

    for (const para of paragraphs) {
        // Check for section heading transitions
        let matched = false;

        // Check separate opinion first (these come after operative)
        if (SEPARATE_OPINION_RE.test(para)) {
            currentSection = 'separate_opinions';
            inSeparateOpinion = true;
            sections[currentSection].push(para);
            matched = true;
            continue;
        }

        if (!inSeparateOpinion) {
            for (const {name, re} of SECTION_PATTERNS) {
                if (re.test(para)) {
                    currentSection = name;
                    matched = true;
                    // Short standalone headings (like "THE FACTS") are not content
                    if (para.length < 80 && !(/^\d+\./.test(para))) {
                        break; // skip adding this as content
                    }
                    sections[currentSection].push(para);
                    break;
                }
            }
        }

        if (!matched) {
            sections[currentSection].push(para);
        }
    }

    return sections;
}

// ============================================================
// Build Case Record
// ============================================================
function buildCaseRecord(meta, textSections) {
    const parseList = (val) => {
        if (Array.isArray(val)) return val;
        if (!val || typeof val !== 'string') return [];
        return val.split(';').map(s => s.trim()).filter(Boolean);
    };

    const parseDate = (val) => {
        if (!val) return '';
        const m = val.match(/(\d{4}[/-]\d{2}[/-]\d{2})/);
        return m ? m[1] : val.substring(0, 10);
    };

    const record = {
        case_id: meta.itemid || '',
        case_no: meta.appno || '',
        title: meta.docname || '',
        judgment_date: parseDate(meta.judgementdate || ''),
        article_no: meta.article || '',
        defendants: parseList(meta.respondent),
        document_type: parseList(meta.doctypebranch),
        originating_body: parseList(meta.originatingbody),
        court: ['European Court of Human Rights'],
        organisation: ['Council of Europe'],
        chamber_composed_of: [],
        violation: parseList(meta.violation),
        'non-violation': parseList(meta.nonviolation),
        court_assessment_references: {},
        ecli: meta.ecli || '',
        importance: meta.importance || '',
        conclusion: meta.conclusion || '',
        separate_opinion: meta.separateopinion || '',
        // Text sections
        introduction: textSections?.introduction || [],
        facts: textSections?.facts || [],
        law: textSections?.law || [],
        relevant_legal_framework_practice: textSections?.relevant_legal_framework_practice || [],
        legal_context: textSections?.legal_context || [],
        reasons_the_court_unanimously: textSections?.reasons_the_court_unanimously || [],
    };

    // Include separate opinions in the record
    if (textSections?.separate_opinions?.length) {
        record.separate_opinions = textSections.separate_opinions;
    }

    return record;
}

// ============================================================
// Main Scraping Loop
// ============================================================
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function startScraping() {
    running = true;
    results = [];
    errors = 0;
    document.getElementById('btnStart').disabled = true;
    document.getElementById('btnStop').style.display = '';
    document.getElementById('btnDownload').style.display = 'none';
    document.getElementById('log').innerHTML = '';

    const idsText = document.getElementById('caseIds').value.trim();
    let metaList = [];

    try {
        if (idsText) {
            // Specific case IDs provided
            const ids = idsText.split(',').map(s => s.trim()).filter(Boolean);
            log(`Will fetch ${ids.length} specific cases`);
            metaList = await fetchMetadataByIds(ids);

            // For any IDs not found in metadata, create minimal stubs
            const foundIds = new Set(metaList.map(m => m.itemid));
            for (const id of ids) {
                if (!foundIds.has(id)) {
                    metaList.push({ itemid: id, docname: 'Unknown (metadata not found)' });
                }
            }
        } else {
            // Search for recent judgments
            metaList = await searchHudoc(100);
        }

        if (!metaList.length) {
            log('No cases found!', 'log-err');
            return;
        }

        log(`Processing ${metaList.length} cases...`, 'log-ok');
        updateProgress(0, metaList.length);

        let totalParas = 0;

        for (let i = 0; i < metaList.length; i++) {
            if (!running) { log('Stopped by user', 'log-warn'); break; }

            const meta = metaList[i];
            const itemId = meta.itemid;
            const title = (meta.docname || '').substring(0, 50);

            try {
                log(`[${i+1}/${metaList.length}] Fetching ${itemId} — ${title}...`);

                const html = await fetchDocumentHtml(itemId);
                const textSections = parseEchrHtml(html);
                const record = buildCaseRecord(meta, textSections);

                // Count paragraphs
                const paraCount = (record.introduction?.length || 0) +
                    (record.facts?.length || 0) +
                    (record.law?.length || 0) +
                    (record.relevant_legal_framework_practice?.length || 0) +
                    (record.reasons_the_court_unanimously?.length || 0);
                totalParas += paraCount;

                results.push(record);
                log(`  ✓ ${paraCount} paragraphs (facts:${record.facts?.length}, law:${record.law?.length})`, 'log-ok');

            } catch (e) {
                errors++;
                log(`  ✗ Error: ${e.message}`, 'log-err');
                // Still add a record with metadata only
                results.push(buildCaseRecord(meta, null));
            }

            document.getElementById('statParas').textContent = totalParas;
            updateProgress(i + 1, metaList.length);

            if (i < metaList.length - 1) await sleep(DELAY_MS);
        }

        log(`\nDone! ${results.length} cases, ${totalParas} paragraphs, ${errors} errors`, 'log-ok');
        document.getElementById('btnDownload').style.display = '';

    } catch (e) {
        log(`Fatal error: ${e.message}`, 'log-err');
    } finally {
        running = false;
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnStop').style.display = 'none';
    }
}

function stopScraping() {
    running = false;
    log('Stopping...', 'log-warn');
}

function downloadResults() {
    if (!results.length) return;
    const lines = results.map(r => JSON.stringify(r));
    const blob = new Blob([lines.join('\n') + '\n'], { type: 'application/jsonl' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const ts = new Date().toISOString().replace(/[:.]/g, '').substring(0, 15);
    a.download = `echr_cases_${ts}.jsonl`;
    a.click();
    URL.revokeObjectURL(url);
    log(`Downloaded ${results.length} cases as JSONL`, 'log-ok');
}

// ============================================================
// Window message handler - allows Claude to inject case IDs and trigger scraping
// ============================================================
window.getResults = () => JSON.stringify({
    count: results.length,
    errors,
    running,
    totalParas: parseInt(document.getElementById('statParas').textContent || '0')
});

window.getResultsJsonl = () => results.map(r => JSON.stringify(r)).join('\n');
</script>
</body>
</html>
